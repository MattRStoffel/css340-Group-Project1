# Design Doc 

### Coding Conventions:

    One True Brace indentation style
    - opening brace at the next line on the same indentation level as its header, the statements within the braces are indented, and the closing brace at the end is on the same indentation level as the header of the function at a line of its own

### Functions: Inputs and Outputs

**Normal Distribution:** 
    Parameters: # of integers to generate, user specified mean, user specified standard deviation
    Output: A histogram containing randomly generated integers in a normal ditrobution

**Uniform Distribution:** 
    Parameters: # of floating-point numbers to generate, user specified range
    Output: A histogram containing randomly generated floating-point in a uniform ditrobution

**Almost Generic QuickSort Algorithm:**
    Parameters: An iterable collection of objects, first index, last index, a comparison function
    Output: The same collection sorted according to the comparison function

**Almost Generic Find k-th ranked object Algorithm:**
    Parameters: An iterable collection of objects, first index, last index, user defined k, a comparison function
    Output: kth item that, if collection were sorted would be at index k of the collection

### Pseudo-Code:

**Normal Distribution:**
1. generate n random integers following a normal distribution, where n is the total count of integers to be produced 
   - use random generator and normal_distribution in std library 
   - O(n) 
   - mean and standard deviation are user-specified
2. generate a histogram with the data (TODO)

**Uniform Distribution:**
1. generate n random integers following a uniform distribution, where n is the total count of integers to be produced
    - use random generator and uniform_distribution in std library
    - O(n)
    - range is user-specified
2. generate a histogram with the data (TODO)


**Almost Generic QuickSort Algorithm:**

quicksort
1. If the low index is less than the high index:
    - Find the pivot index by calling the partition function.
    - Recursively call quickSort on the subarray before the pivot index.
    - Recursively call quickSort on the subarray after the pivot index.

partition
1. Set the pivot element as the last element of the array.
2. Initialize a variable i as (low - 1).
3. Iterate from j = low to high - 1:
    - If the element at index j is less than or equal to the pivot element:
        - Increment i.
        - Swap the elements at indices i and j.
4. Swap the pivot element with the element at index (i + 1).
5. Return the index of the pivot element.

**Almost Generic Find k-th ranked object Algorithm:**

quickselect
1. Find the partition index from partitioning (same function as quicksort) the current array range
2. If the partition index equals k
    - Return partition index
3. Else if partition index is less than k
    - Return quickselect the left range
4. Else if partition index is greater than k
    - Return quickselect the right subarray

### Time-Complexity Analysis:

**Normal Distribution:**
 - Average Case: O(n)
 - Worst Case: O(n)
 - Where n is the number of items in the normal distribution

**Uniform Distribution:**
 - Average Case: O(n) 
 - Worst Case: O(n)
 - Where n is the number of itmes in the uniform distribution

**Almost Generic QuickSort Algorithm:**
 - Average Case: O(n log(n)) 
 - Worst Case: O(n^2)
 - Where n is the size of the array to be sorted

**Almost Generic Find k-th ranked object Algorithm:**
 - Average Case: O(n log(n)) 
 - Worst Case: O(n^2)
 - where n is the size of the array to be searched

### Data Structures, etc:

vectors were preferred over arrays for storing random floats/integers generated by RandomGenerator functions because vectors can be returned directly from a function, but arrays would need to be returned as a pointer, which could complicate memory management and increases the risk of manual de-allocation errors.
